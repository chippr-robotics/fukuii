network {
    server-address {
      # Listening interface for Ethereum protocol connections
      interface = "0.0.0.0"

      # Listening port for Ethereum protocol connections
      port = 9076
    }

    # Try automatic port forwarding via UPnP
    automatic-port-forwarding = true

    discovery {

      # Turn discovery of/off
      discovery-enabled = true

      # Externally visible hostname or IP.
      host = null

      # Listening interface for discovery protocol
      interface = "0.0.0.0"

      # Listening port for discovery protocol
      port = 30303

      # If true, the node considers the bootstrap and the previously persisted nodes
      # as already discovered and uses them as peer candidates to get blocks from.
      # Otherwise it enroll with the bootstrap nodes and gradually discover the
      # network every time we start, eventually serving candidates.
      #
      # Useful if discovery has problem, as the node can start syncing with the
      # bootstraps straight away.
      #
      # Note that setting reuse-known-nodes and discovery-enabled to false at the
      # same time would mean the node would have no peer candidates at all.
      reuse-known-nodes = true

      # Scan interval for discovery
      # Increased from 1 minute to 2 minutes to reduce network overhead and peer churn
      scan-interval = 2.minutes

      # Discovery message expiration time
      message-expiration = 1.minute

      # Maximum amount a message can be expired by,
      # accounting for possible discrepancies between nodes' clocks.
      max-clock-drift = 15.seconds

      # Maximum number of peers in each k-bucket.
      kademlia-bucket-size = 16

      # Timeout for individual requests like Ping.
      # Increased from 1s to 3s to allow for network latency and prevent premature timeouts
      request-timeout = 3.seconds

      # Timeout to collect all possible responses for a FindNode request.
      # Increased from 5s to 10s to allow more time for responses on high-latency networks
      kademlia-timeout = 10.seconds

      # Level of concurrency during lookups and enrollment.
      kademlia-alpha = 3

      # Maximum number of messages in the queue associated with a UDP channel.
      channel-capacity = 100
    }

    known-nodes {
      # How often known nodes updates are persisted to disk
      persist-interval = 20.seconds

      # Maximum number of persisted nodes
      max-persisted-nodes = 200
    }

    peer {
      # DevP2P protocol version advertised in Hello handshake.
      # Compression is only expected when this is >= 5.
      # Override per environment to force compression off (set to 4) during investigations.
      p2p-version = 5

      # Retry delay for failed attempt at connecting to a peer
      # Increased from 5s to 15s to reduce connection churn and give network conditions time to stabilize
      connect-retry-delay = 15 seconds

      # Maximum number of reconnect attempts after the connection has been initiated.
      # After that, the connection will be dropped until its initiated again (eg. by peer discovery)
      # Reduced from 3 to 2 to fail faster and try new peers instead of retrying failing connections
      connect-max-retries = 2

      disconnect-poison-pill-timeout = 15 seconds

      wait-for-hello-timeout = 5 seconds

      wait-for-status-timeout = 30 seconds

      wait-for-chain-check-timeout = 15 seconds

      # Increased from 6s to 10s to allow for slower handshakes on high-latency networks
      wait-for-handshake-timeout = 10 seconds

      # Increased from 10s to 15s to prevent premature TCP write failures
      wait-for-tcp-ack-timeout = 15 seconds

      # Maximum block headers in a single response message (as a blockchain host)
      # ETH protocol uses 2MB soft response limit (core-geth)
      # Block headers are ~500-600 bytes each; pushed to safe maximum
      # 1024 headers ≈ 512-614KB, well under 2MB limit with significant margin
      max-blocks-headers-per-message = 1024

      # Maximum block bodies in a single response message (as a blockchain host)
      # Block bodies vary widely (empty blocks to full blocks with many txs)
      # Average block ~20-50KB, setting to 50 blocks ≈ 1-2.5MB under typical conditions
      # Reduced from 100 to 50 to stay reliably under 2MB soft limit
      max-blocks-bodies-per-message = 50

      # Maximum transactions receipts in a single response message (as a blockchain host)
      # Receipts vary by log count: simple ~200-500 bytes, complex with logs ~1-5KB
      # 1024 receipts at 1KB average ≈ 1MB, safe maximum under 2MB limit
      max-receipts-per-message = 1024

      # Maximum MPT components in a single response message (as a blockchain host)
      max-mpt-components-per-message = 200

      # Minimum number of peers this node tries to connect to at all times
      min-outgoing-peers = 20

      # Maximum number of peers this node can connect to at any time.
      # It's a bit higher than max-incoming-peers so that the node can quickly churn through incompatible peers after startup.
      max-outgoing-peers = 50

      # Maximum number of peers that can connect to this node.
      # Should be at least as much as `min-outgoing-peers` so on a network level `total(max-in) >= total(min-out)`
      max-incoming-peers = 30

      # Number of incoming peers to prune if we hit the maximum, to free up slots for new connections.
      prune-incoming-peers = 10

      # Minimum age of peers before they can be selected for pruning, and the minimum time to pass between pruning attempts.
      min-prune-age = 30.minutes

      # Maximum number of peers that can be connecting to this node
      max-pending-peers = 20

      # Initial delay before connecting to nodes
      # Increased from 10s to 15s to allow discovery to populate more candidates before connecting
      update-nodes-initial-delay = 15.seconds

      # Newly discovered nodes connect attempt interval
      # Increased from 30s to 60s to reduce connection churn and AlreadyConnected disconnects
      update-nodes-interval = 60.seconds

      # Peer which disconnect during tcp connection because of too many peers will not be retried for this short duration
      # Reduced from 6 minutes to 3 minutes to allow faster retry when peer slots become available
      short-blacklist-duration = 3.minutes

      # Peer which disconnect during tcp connection because of other reasons will not be retried for this long duration
      # other reasons include: timeout during connection, wrong protocol, incompatible network
      # Reduced from 600 minutes (10 hours) to 60 minutes (1 hour) to allow reconnection to peers
      # that may have had transient issues
      long-blacklist-duration = 60.minutes

      # Resolution of moving window of peer statistics.
      # Will be multiplied by `stat-slot-count` to give the overall length of peer statistics availability.
      stat-slot-duration = 10.minutes

      # How many slots of peer statistics to keep in the moving window, e.g. 60 * 1.minute to keep stats for the last hour with 1 minute resolution.
      stat-slot-count = 72
    }

    rpc {
      http {
        # JSON-RPC mode
        # Available modes are: http, https
        # Choosing https requires creating a certificate and setting up 'certificate-keystore-path' and
        # 'certificate-password-file'
        # See: https://github.com/input-output-hk/fukuii/wiki/Creating-self-signed-certificate-for-using-JSON-RPC-with-HTTPS
        mode = "http"

        # Whether to enable JSON-RPC HTTP(S) endpoint
        enabled = true

        # Listening address of JSON-RPC HTTP(S) endpoint
        interface = "localhost"

        # Listening port of JSON-RPC HTTP(S) endpoint
        port = 8546

        certificate = null
        #certificate {
        # Path to the keystore storing the certificates (used only for https)
        # null value indicates HTTPS is not being used
        #  keystore-path = "tls/fukuiiCA.p12"

        # Type of certificate keystore being used
        # null value indicates HTTPS is not being used
        #  keystore-type = "pkcs12"

        # File with the password used for accessing the certificate keystore (used only for https)
        # null value indicates HTTPS is not being used
        #  password-file = "tls/password"
        #}

        # Domains allowed to query RPC endpoint. Use "*" to enable requests from
        # any domain.
        cors-allowed-origins = []

        # Rate Limit for JSON-RPC requests
        # Limits the amount of request the same ip can perform in a given amount of time
        rate-limit {
          # If enabled, restrictions are applied
          enabled = false

          # Time that should pass between requests
          min-request-interval = 10.seconds

          # Size of stored timestamps for requests made from each ip
          latest-timestamp-cache-size = 1024
        }
      }

      ipc {
        # Whether to enable JSON-RPC over IPC
        enabled = false

        # Path to IPC socket file
        socket-file = ${fukuii.datadir}"/fukuii.ipc"
      }

      # Enabled JSON-RPC APIs over the JSON-RPC endpoint
      # Available choices are: web3, eth, net, personal, fukuii, test, iele, debug, qa, checkpointing
      apis = "eth,web3,net,personal,fukuii,debug,qa,checkpointing"

      # Maximum number of blocks for fukuii_getAccountTransactions
      account-transactions-max-blocks = 1000

      net {
        peer-manager-timeout = 20.seconds
      }

      health {
        # If the best known block number stays the same for more time than this,
        # the healthcheck will consider the client to be stuck and return an error
        no-update-duration-threshold = 30.minutes
        # If the difference between the best stored block number and the best known block number
        # is less than this value, the healthcheck will report that the client is synced.
        syncing-status-threshold = 10
      }

      miner-active-timeout = 30.seconds
    }
  }